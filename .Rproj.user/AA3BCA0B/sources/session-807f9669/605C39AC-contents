

#####################################################################
# function to detect outliers in data prior to ggplot

is_outlier <- function(x) {
  return(x < quantile(x, 0.25) - 1.2 * IQR(x) | x > quantile(x, 0.75) + 1.2 * IQR(x))
}


######################################################################
# convert data.frame columns all at once
convert_col_classes <- function(df,types){
  out <- lapply(1:length(df),FUN = function(i){FUN1 <- switch(types[i],character = as.character,numeric = as.numeric,factor = as.factor); FUN1(df[,i])})
  names(out) <- colnames(df)
  as.data.frame(out,stringsAsFactors = FALSE)
}

######################################################################
# boxplot of beta diversities within- and between- two levels of a factor

beta_div_betw_withn <- function(physeq, dist, variab, verbose = FALSE, btwn_pairwise = FALSE){
  library(microbiome)
  # preparatory part
  if(class(dist) %in% c("matrix", "dist")){
    if(verbose){ print("using dist as distance matrix/distance")}
    dist_mat <- as.matrix(dist)
  }

  if(class(dist) == "character"){

    if(verbose){print(paste0("calculating the <", dist, "> beta diversity..."))}

    dist <- phyloseq::distance(microbiome::transform(physeq, "compositional"), method = dist)
    dist_mat <- as.matrix(dist)
  }

  #get only upper triangle values, remove also the diagonal of 0
  dist_upper <- dist_mat
  dist_upper[lower.tri(dist_upper, diag=TRUE)] <- NA

  #list of sample names for each level in "variab"
  tmp <- meta(physeq) %>%
    rownames_to_column("samp_names") %>%
    select(all_of(c("samp_names", variab)))

  split_samp_names <- split.data.frame(tmp, tmp[[variab]], drop = TRUE)

  rm(tmp)

  if(verbose){print( "extracting within-group diversities...")}
  within_divs <- lapply(split_samp_names, function(s)
    dist_upper[s$samp_names,s$samp_names] %>%
      reshape2::melt() %>%
      .$value %>% # only get the numeric values
      .[complete.cases(.)]# remove the NAs from the vectors, which are not useful
  ) %>%
    .[sapply(., length) != 0]# remove the list elements that are empty


  if(verbose){print("extracting between-group diversities, one-vs-all")}
  between_divs_all <- lapply(split_samp_names, function(s)
    dist_upper[s$samp_names,!(colnames(dist_upper) %in% s$samp_names)] %>%
      reshape2::melt() %>%
      .$value %>% # only get the numeric values
      .[complete.cases(.)]# remove the NAs from the vectors, which are not useful
  ) %>%
    .[sapply(., length) != 0]# remove the list elements that are empty

  # subset the "between" list, so that factor levels are the same
  between_divs_all <- between_divs_all[names(within_divs)]

  if(btwn_pairwise){
    if(verbose){print("extracting between-group diversities, one-vs-one")}

    samp_names_only <- purrr::transpose(split_samp_names)$samp_names
    combinations_levels <- combn(names(purrr::transpose(split_samp_names)$samp_names),2)
    between_divs_pairwise <- list()

    for(i in 1:ncol(combinations_levels)){
      between_divs_pairwise[[paste(combinations_levels[1,i], combinations_levels[2,i], sep = "_vs_")]] <-
        dist_upper[samp_names_only[[combinations_levels[1,i]]], samp_names_only[[combinations_levels[2,i]]]]

      between_divs_pairwise_clean <- lapply(between_divs_pairwise, function(dist)
        reshape2::melt(dist) %>%
          .$value %>% # only get the numeric values
          .[complete.cases(.)]) %>%
        .[sapply(., length) != 0] # remove the NAs from the vectors, which are not useful
    }

  }

  # combine results together

  if(btwn_pairwise){
  betadiv_results <- rbind(bind_rows(lapply(within_divs, as.data.frame), .id = variab) %>%
      set_names(c(variab, "value")) %>% mutate(comparison = "within"),
      bind_rows(lapply(between_divs_all, as.data.frame), .id = variab) %>%
      set_names(c(variab, "value")) %>% mutate(comparison = "between_all"),
      bind_rows(lapply(between_divs_pairwise_clean, as.data.frame), .id = variab) %>%
      set_names(c(paste(variab, "comparison", sep = "_"), "value")) %>% mutate(comparison = "between_pairwise")
  ) %>% as.data.frame()
  }else{
    betadiv_results <- rbind(bind_rows(lapply(within_divs, as.data.frame), .id = variab) %>%
                               set_names(c(variab, "value")) %>% mutate(comparison = "within"),
                             bind_rows(lapply(between_divs_all, as.data.frame), .id = variab) %>%
                               set_names(c(variab, "value")) %>% mutate(comparison = "between_all")
    ) %>% as.data.frame()
  }
  return(betadiv_results)
}


###################
# quick boxplots-violins

plot_boxplots_beta <- function(beta_div_results){

  ## if pairwise divs are included

  ## if pairwise divs are not included


  return(plot_final)
}

######################################################################
# check if a vector is made of nucleotide sequences (also works with RNA and nucleotides = "n" or "N")
is_nucleotide <- function(x){
  l <- sapply(strsplit(x, "*"), function(i) as.character(i) %in%
                c("a", "A", "c", "C", "g", "G", "t", "T", "u", "U", "n", "N"))
  s <- sapply(l, function(i) all(all(i == TRUE) ==TRUE))
  return(all(s==TRUE))

}
###########################################################################################
# generate a fasta file out of reference sequences in your dataset
phyloseq_to_fasta <- function(physeq, seq_location = "tax_table", destination_file = NULL){

  # format option 1: sequences are somewhere in the taxa table
  if(seq_location == "tax_table"){
    tx <- as.data.frame(physeq@tax_table@.Data)
    pos <- sapply(tx, is_nucleotide)
    seqs <- as.character(tx[, pos])
    names(seqs) <- rownames(tx)

    if (is.null(destination_file)){
      return(seqs)
      stop("no destination file for saving refseq data")
      }
  }
  # format option 2: sequences are in the "RefSeq" slot inside the phyloseq object
  if(seq_location == "refseq"){

    seqs <- as.character(refseq(physeq))

    if(is.null(destination_file)){
      return(refseq(physeq))
      stop("no destination file for saving refseq data")
    }

  }
  # write the fasta file
  cat(file = destination_file, paste(">", names(seqs), "\n", seqs, "\n", sep = ""), sep = "")
  cat(paste("\nfasta file written: '", tools::file_path_as_absolute(destination_file), "'", sep = ""))
}



##################################################################
# geometric mean of a data matrix
gm_mean <- function(x, na.rm=TRUE){
  exp(sum(log(x[x > 0]), na.rm=na.rm) / length(x))
}

###############################################################################
# clone a directory and subdirectory's structure into another location
# can specify both an existing and a non-existing target directory location (end_dir)

clone_dir_structure <- function(start_dir, end_dir){

  if (!endsWith(start_dir, "/")){ # need to remove "/" if it is at the end of the input text
    start_dir <- paste(start_dir, "/", sep = "")
  } # strip that character from the end of the start_dir

  d <- list.dirs(start_dir)
  d_clean <- stringr::str_remove(d, start_dir)
  d_clean <- d_clean[nchar(d_clean) != 0]

  while(any(startsWith(d_clean, "/"))){
    d_clean[startsWith(d_clean, "/")] <- substr(x = d_clean[startsWith(d_clean, "/")],
                                                start = 2,
                                                stop = nchar(d_clean[startsWith(d_clean, "/")]))
  }

  end_directories <- paste(paste(end_dir, d_clean, sep = ""), "/", sep = "")
  sapply(end_directories, function(i) dir.create(i, recursive = TRUE))
}


transform_microbiota_ga <- function(physeq, transform){
  # transform otu counts
  if(transform %in% c("asinh", "arcsinh")){
    if(taxa_are_rows(physeq)){
      transformed_otu <- apply(as.matrix(otu_table(physeq)), 1, asinh)
    }else{
      transformed_otu <- apply(as.matrix(otu_table(physeq)), 2, asinh)
    }
    physeq_transf <- physeq
    otu_table(physeq_transf) <- otu_table(transformed_otu,taxa_are_rows = taxa_are_rows(physeq))
    # substitute otu table with newly transformed one
  }else{
    physeq_transf <- microbiome::transform(physeq, transform = transform)
  }

  return(physeq_transf)
}
####################################################################
boxplot_taxon <- function(physeq, taxon, trait, fill = NULL, colour = NULL, transform= "clr", jitter_alpha = NULL){

  physeq_transf <- transform_microbiota_ga(physeq = physeq, transform = transform)

  # prepare data
  if (taxa_are_rows(physeq_transf)){
    otutab <- t(physeq_trasnf@otu_table@.Data)

  }else{ #taxa are not rows
    otutab <- physeq_transf@otu_table@.Data
  }

  colnames(otutab) <- make.names(colnames(otutab))

  identical(rownames(as.data.frame(physeq_transf@sam_data)), rownames(otutab))
  data_merged <- as.data.frame(cbind(otutab, as.data.frame(physeq_transf@sam_data)))
  data_merged[[trait]] <- as.factor(data_merged[[trait]])
  if (!is.null(jitter_alpha)){
    boxp <- ggplot(data = data_merged, aes_string(x = trait, y = make.names(taxon))) + geom_boxplot(aes_string(colour=colour, fill = fill)) + geom_jitter(alpha = jitter_alpha)  + ggtitle(paste("trasnformation method: ", transform, sep = ""))
  }else{
    boxp <- ggplot(data = data_merged, aes_string(x = trait, y = make.names(taxon))) + geom_boxplot(aes_string(colour=colour, fill = fill)) + ggtitle(paste("transformation method: ", transform, sep = ""))
  }

  return(boxp)
}


##########################################################################################
# same as above, but scatterplot

scatterplot_taxon <- function(physeq, taxon, trait, fill = NULL, colour = NULL, transform= "clr", jitter_alpha = NULL){

  real_name <- taxon
  easier_name <- make.names(real_name)

  # transform otu counts
  physeq_transf <- transform_microbiota_ga(physeq, transform = transform)
  taxa_names(physeq_transf) <-make.names(taxa_names(physeq_transf))

  # prepare data
  if (taxa_are_rows(physeq_transf)){
    otutab <- t(physeq_trasnf@otu_table@.Data)

  }else{ #taxa are not rows
    otutab <- physeq_transf@otu_table@.Data
  }
  identical(rownames(as.data.frame(physeq_transf@sam_data)), rownames(otutab))
  data_merged <- as.data.frame(cbind(otutab,as.data.frame(physeq_transf@sam_data)))
  if (!is.null(jitter_alpha)){
    scatpl <- ggplot(data = data_merged, aes_string(x = trait, y = easier_name)) +
      geom_point(aes_string(colour=colour, fill = fill)) +
      geom_jitter(alpha = jitter_alpha)  +
      labs(title = real_name,
           subtitle = paste("trasnformation method: ", transform, sep = "")
           )
  }else{
    scatpl <- ggplot(data = data_merged, aes_string(x = trait, y = easier_name)) +
      geom_jitter(aes_string(colour=colour, fill = fill)) +
      labs(title = real_name,
           subtitle = paste("trasnformation method: ", transform, sep = "")
    )
  }

  return(scatpl)
}

#########################################################################################
# function to make a quick distribution histogram for a taxon

histogram_taxon <- function(physeq, taxon, trait, fill = NULL, transform = "clr", alpha = 1, geom = "choose between 'histogram' and 'density'"){
  physeq_transf <- transform_microbiota_ga(physeq, transform = transform)
  if(geom == "choose between 'histogram' and 'density'"){
    geom <- "histogram"
  }

  otutab <- t(microbiome::abundances(physeq_transf))
  data_merged <- as.data.frame(cbind(otutab,microbiome::meta(physeq_transf)))


  if (geom == "histogram"){
    histplot <- ggplot(data = data_merged, aes_string(x = taxon), colour = "gray 30") +
      geom_histogram(aes_string(fill = fill), alpha = alpha) +
      ggtitle(paste("trasnformation method: ", transform, sep = ""))
  }
  if (geom == "density"){
    histplot <- ggplot(data = data_merged, aes_string(x = taxon), colour = "gray 30") +
      geom_density(aes_string(colour = fill), alpha = alpha) +
      ggtitle(paste("trasnformation method: ", transform, sep = ""))
  }

  return(histplot)
}
##########################################################################################
############ Function to remove na's from wanted variables in a phyloseq object

drop_NA_from_phyloseq_vars <- function(physeq, vars){
  physeq_cleaned <- physeq
  cat("dropping NAs from these variables:\n")
  for(v in vars){
    cat(paste(v, "  "))
    samples_to_save <- meta(physeq_cleaned) %>%
      filter(!is.na(!!rlang::sym(v))) %>%
      rownames()
    tmp <- sample_names(physeq_cleaned) %in% samples_to_save
    physeq_cleaned <- prune_samples(samples = samples_to_save, x =  physeq_cleaned)
  }
  cat("\n")

  return(physeq_cleaned)
}


##########################################################################################
# plot_bar function, with customizable border

plot_bar2 <-  function (physeq, x = "Sample", y = "Abundance", fill = NULL, title = NULL, facet_grid = NULL, border_color = NA){
  mdf = psmelt(physeq)
  p = ggplot(mdf, aes_string(x = x, y = y, fill = fill))
  p = p + geom_bar(stat = "identity", position = "stack",  color = border_color)
  p = p + theme(axis.text.x = element_text(angle = -90, hjust = 0))
  if (!is.null(facet_grid)) {
    p <- p + facet_grid(facet_grid)
  }
  if (!is.null(title)) {
    p <- p + ggtitle(title)
  }
  return(p)
}

##################################################################################################
# to write all combinations of results for a DESeq2 object and a trait of interest
deseq_results_into_csv_files <- function(deseq_results, trait, target_dir, physeq_obj = NULL, physeq_aggr_lvl, taxon_lvls_added = "all", sort_p.val = TRUE, shorten_name = FALSE){
  combin <- (t(combn(levels(deseq_results[[trait]]),2)))
  library(DESeq2)
  for (l in 1: nrow(combin)){
    if(sort_p.val){
      if(!is.null(physeq_obj)){ # if you want to arrange p value and add taxonomic info
        write.csv(results(deseq_results, contrast =c(trait, combin[l,1], combin[l,2])) %>% as.data.frame() %>%
                    tibble::rownames_to_column(physeq_aggr_lvl) %>%
                    add_ASV_name_to_ASV_results(., col_ASV = physeq_aggr_lvl, physeq = physeq_obj, tax_lvls = taxon_lvls_added)%>% arrange(padj),
                  file = paste(target_dir, ifelse(shorten_name,"", "data=chrismb; "), "trait=", trait,"; ","contrast=", combin[l,1], "_vs_", combin[l,2], ".csv", sep = ""))
      } else{ # arrange p value but no taxonomic info
        write.csv(results(deseq_results, contrast =c(trait, combin[l,1], combin[l,2])) %>% as.data.frame() %>%
                    tibble::rownames_to_column(physeq_aggr_lvl) %>%
                    arrange(padj),
                  file = paste(target_dir, ifelse(shorten_name,"", "data=chrismb; "), "trait=", trait,"; ","contrast=", combin[l,1], "_vs_", combin[l,2], ".csv", sep = ""))
      }
    } else{ # do not arrange p value
      if(!is.null(physeq_obj)){ # do not arrange p value but add ASV info
        write.csv(results(deseq_results, contrast =c(trait, combin[l,1], combin[l,2])) %>% as.data.frame() %>%
                    tibble::rownames_to_column(physeq_aggr_lvl)%>%
                    add_ASV_name_to_ASV_results(., col_ASV = physeq_aggr_lvl, physeq = physeq_obj, tax_lvls = taxon_lvls_added),
                  file = paste(target_dir, ifelse(shorten_name,"", "data=chrismb; "), "trait=", trait,"; ","contrast=", combin[l,1], "_vs_", combin[l,2], ".csv", sep = ""))
      } else{ # do not arrange p value nor add ASV info
        write.csv(results(deseq_results, contrast =c(trait, combin[l,1], combin[l,2])) %>% as.data.frame()%>%
                    tibble::rownames_to_column(physeq_aggr_lvl),file = paste(target_dir, ifelse(shorten_name,"", "data=chrismb; "), "trait=", trait,"; ","contrast=", combin[l,1], "_vs_", combin[l,2], ".csv", sep = ""))
      }

    }

  }

}

############
# this function does the same as the write_deseq... but returns you directly the data frame list
deseq_results_into_list <- function(deseq_results, trait, physeq_obj = NULL, physeq_aggr_lvl, taxon_lvls_added = "all", sort_p.val = TRUE, shorten_name = FALSE){
  combin <- (t(combn(levels(deseq_results[[trait]]),2)))
  library(DESeq2)

  results_list <- list()
  for (l in 1: nrow(combin)){
    if(sort_p.val){
      if(!is.null(physeq_obj)){ # if you want to arrange p value and add taxonomic info
        results_list[[paste(combin[l,1], "_vs_", combin[l,2], sep = "")]] <- results(deseq_results, contrast =c(trait, combin[l,1], combin[l,2])) %>% as.data.frame() %>%
          tibble::rownames_to_column(physeq_aggr_lvl) %>%
          add_ASV_name_to_ASV_results(., col_ASV = physeq_aggr_lvl, physeq = physeq_obj, tax_lvls = taxon_lvls_added)%>% arrange(padj)
      } else{ # arrange p value but no taxonomic info
        results_list[[paste(combin[l,1], "_vs_", combin[l,2], sep = "")]] <- results(deseq_results, contrast =c(trait, combin[l,1], combin[l,2])) %>% as.data.frame() %>%
          tibble::rownames_to_column(physeq_aggr_lvl)
      }
    } else{ # do not arrange p value
      if(!is.null(physeq_obj)){ # do not arrange p value but add ASV info
        results_list[[paste(combin[l,1], "_vs_", combin[l,2], sep = "")]] <- results(deseq_results, contrast =c(trait, combin[l,1], combin[l,2])) %>% as.data.frame() %>%
          tibble::rownames_to_column(physeq_aggr_lvl)%>%
          add_ASV_name_to_ASV_results(., col_ASV = physeq_aggr_lvl, physeq = physeq_obj, tax_lvls = taxon_lvls_added)
      } else{ # do not arrange p value nor add ASV info
        results_list[[paste(combin[l,1], "_vs_", combin[l,2], sep = "")]] <-  results(deseq_results, contrast =c(trait, combin[l,1], combin[l,2])) %>% as.data.frame()%>%
          tibble::rownames_to_column(physeq_aggr_lvl)
      }

    }

  }
  return(results_list)
}

###################################################################################
phyloseq_to_edgeR <- function(physeq, group, method="RLE", ...){
  require("edgeR")
  require("phyloseq")
  # Enforce orientation.
  if( !taxa_are_rows(physeq) ){ physeq <- t(physeq) }
  x = as(otu_table(physeq), "matrix")
  # Add one to protect against overflow, log(0) issues.
  x = x + 1
  # Check `group` argument
  if( identical(all.equal(length(group), 1), TRUE) & nsamples(physeq) > 1 ){
    # Assume that group was a sample variable name (must be categorical)
    group = get_variable(physeq, group)
  }
  # Define gene annotations (`genes`) as tax_table
  taxonomy = tax_table(physeq, errorIfNULL=FALSE)
  if( !is.null(taxonomy) ){
    taxonomy = data.frame(as(taxonomy, "matrix"))
  }
  # Now turn into a DGEList
  y = DGEList(counts=x, group=group, genes=taxonomy, remove.zeros = TRUE, ...)
  # Calculate the normalization factors
  z = calcNormFactors(y, method=method)
  # Check for division by zero inside `calcNormFactors`
  if( !all(is.finite(z$samples$norm.factors)) ){
    stop("Something wrong with edgeR::calcNormFactors on this data,
         non-finite $norm.factors, consider changing `method` argument")
  }
  # Estimate dispersions
  return(estimateTagwiseDisp(estimateCommonDisp(z)))
}


#############################################################################

save_tags <- function (tags, file, selfcontained = F, libdir = "./lib")
{
  if (is.null(libdir)) {
    libdir <- paste(tools::file_path_sans_ext(basename(file)),
                    "_files", sep = "")
  }
  htmltools::save_html(tags, file = file, libdir = libdir)
  if (selfcontained) {
    if (!htmlwidgets:::pandoc_available()) {
      stop("Saving a widget with selfcontained = TRUE requires pandoc. For details see:\n",
           "https://github.com/rstudio/rmarkdown/blob/master/PANDOC.md")
    }
    htmlwidgets:::pandoc_self_contained_html(file, file)
    unlink(libdir, recursive = TRUE)
  }
  return(file)
}
###########################################################################
# from GitHub/jasdumas, https://github.com/jasdumas/data-exploreR/blob/master/www/flattenCorrMatrix.R

flattenCorrMatrix <- function(cormat, pmat) {
  ut <- upper.tri(cormat)
  data.frame(
    row = rownames(cormat)[row(cormat)[ut]],
    column = rownames(cormat)[col(cormat)[ut]],
    cor  =(cormat)[ut],
    p = pmat[ut]
  )
}
############################################################################

find_char_in_string <- function(str, chars_to_check, is.there = TRUE){
  if(is.there){
    v <- chars_to_check[sapply(chars_to_check, function(i) grepl(i, str))]
    return(v)
  }else{
    v <- chars_to_check[!sapply(chars_to_check, function(i) grepl(i, str))]

  }

}

##########################################################################
extract_corncob_results_catecorical <- function(res, variable_of_interest, contrast_lvl ="choose another level of the factor, remember that the first is the baseline", tax_lvl, differential_test = "choose between 'Abundance', 'Variability'"){
  p <- plot(res, tax_lvl)$data
  pvals_df <- data.frame(taxa = names(res$p),
                         pval = res$p,
                         padj = res$p_fdr)

  var_contrasts <- strsplit(p$variable, "\n") %>% sapply("[", 1) %>% strsplit(variable_of_interest, fixed = T) %>% sapply("[", 2)
  differential_operation <- strsplit(p$variable, "\n") %>% sapply("[", 2) %>% strsplit(" ") %>% sapply("[", 2)
  p$variable <- var_contrasts
  p$type_of_differential_operation <- differential_operation

  p <- merge(p, pvals_df, all.x = TRUE, by = "taxa")
  colnames(p) <- c(tax_lvl,"FoldChange", "stderror-", "stderror+", "contrast_numerator", "type_of_differential_operation", "pval", "padj")
  p <- p[,c(1:4,7,8,5,6)]

  # filter the type of differential analysis wanted
  p_subs <- p %>% filter(contrast_numerator == contrast_lvl)
  if(differential_test == "both"){
    p %>% filter(contrast_numerator == contrast_lvl) %>%
      return()
  } else{
    p %>% filter(type_of_differential_operation == differential_test) %>% filter(contrast_numerator == contrast_lvl) %>%
      return()
  }

}


#################################################
### custom correlation matrix and p value
cor.pmat <- function(x,method = corr.method, ...) {
  mat <- as.matrix(x)
  n <- ncol(mat)
  p.mat<- matrix(NA, n, n)
  colnames(p.mat) <- colnames(mat)
  rownames(p.mat) <- colnames(mat)
  diag(p.mat) <- 0
  for (i in 1:(n - 1)) {
    for (j in (i + 1):n) {
      tmp <- cor.test(mat[, i], mat[, j], ...)
      #print(tmp$p.value)
      p.mat[i, j] <- tmp$p.value
      p.mat[j, i] <- tmp$p.value
    }
  }

  return(as.matrix(p.mat))
}

corr_matrix_and_signif_custom <- function(mat_or_df, corr.method){

  l <- list(matrix_r = cor(mat_or_df, method = corr.method),
            matrix_p = cor.pmat(mat_or_df, method = corr.method)
  )
  return(l)
}

#################################################################
## extract corncob results for the significant taxa
extract_corncob_results_continuous <- function(corncob_res, which_differential = "DA", variab_estim_to_extract, taxa_to_extract = "significant"){
  if (which_differential == "both"){
    extrc <- paste(c("mu", "phi"), variab_estim_to_extract, sep = ".")
  }
  if(which_differential == "DA"){
    extrc <- paste("mu", variab_estim_to_extract, sep = ".")
  }
  if(which_differential == "DV"){
    extrc <- paste("phi", variab_estim_to_extract, sep = ".")
  }

  if(taxa_to_extract == "significant"){
    tmp <- corncob_res$significant_models
    names(tmp) <- corncob_res$significant_taxa

    padj_df <- corncob_res$p_fdr[names(corncob_res$p_fdr) %in% corncob_res$significant_taxa] %>%
      as.data.frame() %>%
      rownames_to_column("Genus") %>%
      dplyr::rename(., padj = .)

    tmp_signif_coeffs_corncob <- lapply(tmp , coefficients) %>%
      lapply(function(i) as.data.frame(i) %>% rownames_to_column("variab")) %>%
      lapply(function(i) i[i[,1] %in% extrc,]) %>%
      bind_rows(.id = "Genus")


    colnames(tmp_signif_coeffs_corncob) <- c("Genus", "estim_name","estimate", "estimate.SE", "t_value", "pvalue")

    extracted_output <- merge(tmp_signif_coeffs_corncob, padj_df, by = "Genus", all.x = TRUE, sort = FALSE) %>%
      mutate(method = "corncob")
  }
  if (taxa_to_extract == "all"){
    tmp <- corncob_res$all_models
    names(tmp) <- names(corncob_res$p)

    tmp_signif_coeffs_corncob <- lapply(tmp , coefficients) %>%
      lapply(function(i) as.data.frame(i) %>% rownames_to_column("variab")) %>%
      lapply(function(i) i[i[,1] %in% extrc,]) %>%
      bind_rows(.id = "Genus")


    colnames(tmp_signif_coeffs_corncob) <- c("Genus", "estim_name","estimate", "estimate.SE", "t_value", "pvalue")

    extracted_output <- tmp_signif_coeffs_corncob %>%
      mutate(method = "corncob")
  }

  return(extracted_output)
}

###################################################

open.plot.directory <- function(plot_path){

  if (.Platform$OS.type == "windows"){
    if(!(str_sub(plot_path, start = nchar(plot_path), end = nchar(plot_path)) == "/")){ # if the directory name given ends with "/", then we can play with it without manipulation, otherwise, we need to do some managing
      s <- strsplit(plot_path, "/")[[1]]
      s_sub <- s[1:length(s)-1]
      plot_path_windows <- paste(s_sub, collapse = "\\") %>% paste("\\", sep = "")
    } else{ # if it ends with "/", just translate the "/" character
      plot_path_windows <- gsub(pattern = "/", replacement = "\\\\", x = plot_path)
    }

    shell.exec(plot_path_windows)
  } else{ # if it is not windows
    if(!(str_sub(plot_path, start = nchar(plot_path), end = nchar(plot_path)) == "/")){
      s <- strsplit(plot_path, "/")[[1]]
      s_sub <- s[1:length(s)-1]
      plot_path_unix <- paste(s_sub, collapse = "/") %>% paste("/", sep = "")
      system(paste(Sys.getenv("R_BROWSER"), plot_path_unix))
    } else{
      system(paste(Sys.getenv("R_BROWSER"), plot_path))
    }

  }
}

###############################################################################NOT READY
# function to merge metadata of phyloseq to ordintated distance
metadata_with_ordination <- function(ord, phy, n_axes){
  variance_explained <- round(ord$values[,2]*100, 1)
  vectors <- ord$vectors[,1:n_axes]
  colnames(vectors) <- paste(colnames(vectors), " (",variance_explained[n_axes], "%)", sep = "")
  return(vectors)
}

###################################################################
save_tmp_ggfigure <- function(Robj, format, ...){
  tmp_hour <- Sys.time() %>% as.character() %>% strsplit(" ") %>% sapply("[", 2)
  tmp_hour_nicer <- paste("time=", gsub(x = tmp_hour, pattern = ":", replacement = ".", fixed = T), sep = "")
  final_name <- paste("date=", Sys.Date()," ; ", tmp_hour_nicer, sep = "")
  # tmp_name <-
  suppressWarnings(dir.create("~/../Desktop/tmp/R_tmp_figures/", recursive = TRUE))
  ggsave(plot = Robj, filename = paste("~/../Desktop/tmp/R_tmp_figures/",final_name, ".", format, sep = ""), dpi = ..., height = ..., width = ...)
}
###################################################################

dont_know_function <- function(physeq,
                               individual_id,
                               taxon,
                               transform,
                               covariates,
                               dest_directory) {
  taxon <- make.names(taxon)
  # transform sample counts,
  # allowed ones are inside microbiome::transform and the arcsinh
  physeq <-
    transform_microbiota_ga(physeq = physeq, transform = transform)

  # get otu table
  if (taxa_are_rows(physeq)) {
    otutable <- t(otu_table(physeq))
  } else{
    otutable <- otu_table(physeq)
  }
  # simplify names, which would otherwise mess up with the following functions
  # also make sure they are numeric
  otutable <- data.frame(otutable)
  colnames(otutable) <- make.names(colnames(otutable))
  otutable <- apply(otutable, 2, as.numeric)
  # get metadata table
  metatable <- microbiome::meta(physeq)

  # get only variables of interest
  metatable_onlyvarsofInterest <-
    metatable[, c(rep(individual_id, 4),
                  covariates)] %>%
    cbind(., otutable[, taxon]) %>%
    data.frame() %>%
    mutate(sex = ifelse(sex == "male", 1, 2))

  colnames(metatable_onlyvarsofInterest) <-
    c("#FAM_ID", "IND_ID", "FAT_ID", "MOT_ID", covariates, taxon)
  rownames(metatable_onlyvarsofInterest) <- NULL

  # this applies if we make a ped with multiple genera in it
  data.table::fwrite(
    x = metatable_onlyvarsofInterest,
    file = paste(
      dest_directory,
      "/",
      "mbGWAS_PED_ntaxa.",
      length(taxon),
      ".ped",
      sep = ""
    ),
    sep = "\t"
  )

}
###################################################################

####### function that beeps when launched
notify_me <- function(n = 3){
  for(i in seq(n)){
    system("rundll32 user32.dll,MessageBeep -1")
    Sys.sleep(.5)
  }
}

###################################################################

prevalence_table_trait <- function(physeq, trait){
  library(phyloseq)
  library(tidyverse)
  if(identical(sample_names(physeq), rownames(microbiome::meta(physeq)))){
    otu <- t(microbiome::abundances(physeq))
    otu[otu!=0] <- 1
    otu_split <- as.data.frame(otu) %>%
      split.data.frame(f = microbiome::meta(physeq)[[trait]]) %>%
      lapply(function(df) colSums(df)/nrow(df))

    names(otu_split) <- levels(factor(microbiome::meta(physeq)[[trait]]))
  }else{
    stop("names not matching, I can't support this yet")
  }

  return(bind_rows(otu_split,.id = trait) %>% column_to_rownames(trait) %>%  t())
}

##################################################################

date_to_Season <- function(dat) {
  stopifnot(class(dat) == "Date")
  scalarCheck <- function(dat) {
    m <- as.POSIXlt(dat)$mon + 1        # correct for 0:11 range
    d <- as.POSIXlt(dat)$mday           # correct for 0:11 range
    if ((m == 3 &
         d >= 21) | (m == 4) | (m == 5) | (m == 6 & d < 21)) {
      r <- 1
    } else if ((m == 6 &
                d >= 21) | (m == 7) | (m == 8) | (m == 9 & d < 21)) {
      r <- 2
    } else if ((m == 9 &
                d >= 21) | (m == 10) | (m == 11) | (m == 12 & d < 21)) {
      r <- 3
    } else {
      r <- 4
    }
    r
  }

  res <- sapply(dat, scalarCheck)
  res <-
    ordered(res, labels = c("Spring", "Summer", "Autumn", "Winter"))
  return(res)
}


#######################################################################       INCOMPLETE
### microbiome heatmap based on the pheatmap function

heatmap_microbiome <- function(physeq,
           variable,
           physeq_transformation = "compositional",
           taxa = "all",
           aggregation_samples = "median",
           scale = "row",
           add_sample_number = TRUE,
           taxa_in_rows = TRUE,
           angle_col = "90",
           legend = FALSE,
           treeheight_row = 20,
           treeheight_col = 20) {
  library(tidyverse)
    # aggregation_samples can be any of c("none", "median", "mean"). with  "none", it keeps individual data, but color extra by variable
    # get only taxa you want
    if (taxa != "all") {
      physeq <- subset_taxa(physeq, taxa_names(physeq) %in% taxa)

    }
  # transform the microbiome data as requested
    physeq_transf <-
      microbiome::transform(physeq, transform = physeq_transformation)

    # by default,  the function will plot the number of samples per category
    if (add_sample_number){
    sample_n <- microbiome::meta(physeq_transf)[[variable]] %>%
      table() %>%
      as.data.frame() %>%
      set_names(c(variable, "counts")) %>%
      mutate(variable_with_n  = paste0(!!rlang::sym(variable), " (n=", counts, ")"))

    # substitute new metadata, which will have the same variable, but also with number of samples
    new_meta <- right_join(microbiome::meta(physeq_transf), sample_n, by = variable, sort = FALSE)
    rownames(new_meta) <- rownames(microbiome::meta(physeq_transf))

    physeq_transf <- substitute_metadata(physeq_transf, new_meta)
      variable <- "variable_with_n"
    }

    # split asv table based on variable chosen
    if (aggregation_samples %in% c("median", "mean")) {
      metadata_and_asvs <-  physeq_transf %>%
        microbiome::abundances() %>% t() %>%
        as.data.frame() %>%
        rownames_to_column("id") %>%
        merge(select(microbiome::meta(physeq_transf), all_of(variable)) %>% rownames_to_column("id"),
                   by = "id", sort=FALSE) %>% # merge the two data frame, one is otu table, the other is the metadata with the variable of interest
        select(-id) %>% # remove id variable, it is not necessary anymore
        split.data.frame(f = .[[variable]], drop = TRUE) %>% # split the data frame and keep names
        lapply(function(df)
          select(df,-matches(variable))) # remove leftover variable used to split

      if (aggregation_samples == "median") {
        aggregated_data <-
          lapply(metadata_and_asvs, function(df)
            apply(df, 2, median, na.rm = FALSE)) %>% bind_rows(.id = variable) %>% column_to_rownames(variable)

      }
      if (aggregation_samples == "mean") {
        aggregated_data <-
          lapply(metadata_and_asvs, function(df)
            apply(df, 2, mean, na.rm = FALSE)) %>% bind_rows(.id = variable) %>% column_to_rownames(variable)
      }

      # transpose to have taxa in rows or columns, as preferred
      scale_options <- c("row", "column")
      if(taxa_in_rows){ # if the variable is TRUE
        data_ready_to_plot <- t(aggregated_data)
        scale <- scale_options[!(scale == scale_options)]

      }else{
        data_ready_to_plot <- aggregated_data
        if(scale != "none"){

        }
      }

      return(pheatmap::pheatmap(
        data_ready_to_plot,
        # don't show colnames, which with this settings are sample names
        treeheight_row = treeheight_row,
        treeheight_col = treeheight_col, # don't draw trees
        scale = scale,
        angle_col = angle_col,
        legend = legend))
    }

    if (aggregation_samples == "none") {
      data_ready_to_plot <- abundances(physeq_transf)
      color_variable <-
        select(microbiome::meta(physeq_transf), all_of(variable))

      return(pheatmap::pheatmap(
        data_ready_to_plot,
        annotation = color_variable,
        show_colnames = FALSE,
        # don't show colnames, which with this settings are sample names
        treeheight_row = treeheight_row,
        treeheight_col = treeheight_col, # don't draw trees
        scale = scale,
        angle_col = angle_col,
        legend = legend))

      print(pheatmap::pheatmap(
        data_ready_to_plot,
        annotation = color_variable,
        show_colnames = FALSE,
        # don't show colnames, which with this settings are sample names
        treeheight_row = treeheight_row,
        treeheight_col = treeheight_col, # don't draw trees
        scale = scale,
        angle_col = angle_col,
        legend = legend))
    }
  }


################################################################################
################ function to rename columns in a pipeline instead of stopping it and write that line you see in the function. it's just handy sometimes
replace_colnames <- function(df, new_colnames){
  colnames(df) <- new_colnames
  return(df)
}

replace_rownames <- function(df, new_rownames){
  rownames(df) <- new_rownames
  return(df)
}

##############################################################################
#### function to make pairwise chisq tests into data frame, with also p.adj estimates

pairwise_chisq <- function(df, vars, padj_method = "BH", ...){
  library(tidyverse)

  combinations <- combn(vars, 2) %>%
    t() %>%
    as.data.frame() %>%
    #filter(!(Var1 == Var2)) %>%
    mutate(combins = paste(V1, V2, sep = "_vs_"))

  tmp <- lapply(strsplit(combinations$combins, split = "_vs_"), function(cbn)
    chisq.test(table(df[[cbn[1]]], df[[cbn[2]]]), simulate.p.value = 2000))
  names(tmp) <- combinations$combins


  stats_summary_df <- rbind(sapply(tmp, "[[", 1), sapply(tmp, "[[",3)) %>%
    t() %>%
    as.data.frame() %>%
    mutate(comparisons = names(tmp)) %>%
    remove_rownames() %>%
    dplyr::rename(statistic = V1,
                  p.value = V2) %>%
    separate("comparisons", into = c("var1", "var2"),sep = "_vs_", remove = TRUE) %>%
    mutate(p.adj = p.adjust(p.value, method = padj_method)) %>%
    select(var1, var2, p.value, p.adj)
  return(stats_summary_df)

}

##############################################################################
#### function to change list structure. list has to be max of 2 levels
# 1 - courtesy of  https://stackoverflow.com/questions/15263146/revert-list-structure
# 2 - also similar implementation in paleotree::reverseList

revert_list_str <- function(ls) {
  res <- lapply(names(ls[[1]]), function(n, env) {
    name <- paste(n, 'elements', sep = '_')
    assign(name, vector('list', 0))
    inner <- sapply(ls, function(x) {
      assign(name, c(get(name), x[which(names(x) == n)]))
    })
    names(inner) <- names(ls)

    inner
  })
  names(res) <- names(ls[[1]])

  res
}

#############################################################################
### function to prepare a phyoseq to PICRUSt2
phyloseq2picrust <- function(physeq, output.dir, refseq_location="refseq"){
  # write biom-formated ASV table
  biomformat::write_biom(x = biomformat::make_biom(microbiome::abundances(physeq)),
                         biom_file = paste0(output.dir, "/chrismb_asv_table.biom"))
  # write refseq into FASTA (actuall, .fna) file
  phyloseq_to_fasta(physeq = physeq,
                    seq_location = refseq_location,
                    destination_file = paste0(output.dir, "/chrismb_refseqs.fna"))

  cat(paste("\n", "PICRUSt2 input files saved into", output.dir, "\n"))
}

#####################################################################
# function to generate random operations and prints them as LaTeX output

addizioni_random <- function(n_operazioni, numero_cifre_primo_addendo = NULL, numero_cifre_secondo_addendo= NULL, numero_decimali = 0, limite_somme, file_output = "~/tmp"){

  substrRight <- function(x, n){
    substr(x, nchar(x)-n+1, nchar(x))
  }
  # final_operations <- rep("", n_operazioni)

  min_x <- ifelse(is.null(numero_cifre_primo_addendo), 1, 10^(numero_cifre_primo_addendo -1))
  min_y <- ifelse(is.null(numero_cifre_secondo_addendo), 1, 10^(numero_cifre_secondo_addendo -1))

  addends_1 <- round(runif(n = n_operazioni*10, min = min_x, max = limite_somme-1), numero_decimali)
  addends_2 <- sapply(addends_1, function(addend) round(runif(n = 1, min = 1, max = 99-addend)), numero_decimali)

  sums_units <- as.integer(substrRight(addends_1, 1)) + as.integer(substrRight(addends_2, 1))
  decrease_units <- sums_units - 9
  decrease_units_divided_by2 <- ifelse(decrease_units == 1, rbinom(1, 1, 0.5), round(decrease_units/2,0))

  addends_1[decrease_units > 0] <- addends_1[decrease_units > 0] - decrease_units_divided_by2[decrease_units > 0]
  addends_2[decrease_units > 0] <- addends_2[decrease_units > 0] - decrease_units_divided_by2[decrease_units > 0]

  final_operations <- paste(addends_1,"+",addends_2, "=        ")

  # write the operations
  if(file_output =="~/tmp"){
    dir.create("~/tmp")
  }
  cat(final_operations, file = paste0(file_output, "/", n_operazioni, "sums_", Sys.Date(), ".txt"),
      append = TRUE,
      sep = "\n")

  cat(paste("operazioni salvate nel file: ", paste0(file_output, "/", n_operazioni, "sums_", Sys.Date(), ".txt")))

  # create a function to open plot directory
  open.plot.directory <- function(plot_path){

    if (.Platform$OS.type == "windows"){
      if(!(str_sub(plot_path, start = nchar(plot_path), end = nchar(plot_path)) == "/")){ # if the directory name given ends with "/", then we can play with it without manipulation, otherwise, we need to do some managing
        s <- strsplit(plot_path, "/")[[1]]
        s_sub <- s[1:length(s)-1]
        plot_path_windows <- paste(s_sub, collapse = "\\") %>% paste("\\", sep = "")
      } else{ # if it ends with "/", just translate the "/" character
        plot_path_windows <- gsub(pattern = "/", replacement = "\\\\", x = plot_path)
      }

      shell.exec(plot_path_windows)
    } else{ # if it is not windows
      if(!(str_sub(plot_path, start = nchar(plot_path), end = nchar(plot_path)) == "/")){
        s <- strsplit(plot_path, "/")[[1]]
        s_sub <- s[1:length(s)-1]
        plot_path_unix <- paste(s_sub, collapse = "/") %>% paste("/", sep = "")
        system(paste(Sys.getenv("R_BROWSER"), plot_path_unix))
      } else{
        system(paste(Sys.getenv("R_BROWSER"), plot_path))
      }

    }
  }
  # open directory of file created
  open.plot.directory(paste0(file_output, "/", n_operazioni, "sums_", Sys.Date(), ".txt"))
}



sottrazioni_random <- function(n_operazioni, numero_cifre_minuendo = NULL, numero_cifre_sottraendo = NULL, numero_decimali = 0, prestito = FALSE, file_output = "~/tmp"){

  substrRight <- function(x, n){
    substr(x, nchar(x)-n+1, nchar(x))
  }

  x_min <- ifelse(is.null(numero_cifre_minuendo), 1, 10^(numero_cifre_minuendo-1))
  y_min <- ifelse(is.null(numero_cifre_sottraendo), 1, 10^(numero_cifre_sottraendo-1))

  x_max <- ifelse(is.null(numero_cifre_minuendo), 1, 10^(numero_cifre_minuendo)-1)
  y_max <- ifelse(is.null(numero_cifre_sottraendo), 1, 10^(numero_cifre_minuendo)-1)

  minuendo <- round(runif(n = n_operazioni, min = x_min, max = x_max))
  sottraendo <- round(sapply(minuendo, function(minuendo) runif(1, min = x_min, max = minuendo-1)))

  # se ci sono decimali, allora la persona sa fare prestiti,
  # quindi servono entrambe queste condizioni perch? sia necessario un'eliminazione del prestito

  if(numero_decimali == 0 & isFALSE(prestito)){

    #estrai le unit? soltanto
    minuendo_units <- substrRight(minuendo, 1)
    sottraendo_units <- substrRight(sottraendo, 1)
    # vettore logico dei casi limite, in cui il minuendo ha meno unit? del sottraendo
    casi_limite <- as.integer(minuendo_units) < as.integer(sottraendo_units)
    tmp <- minuendo_units
    #inverti casi non ottimali di sottrazione
    minuendo_units[casi_limite] <- sottraendo_units[casi_limite]
    sottraendo_units[casi_limite] <- tmp[casi_limite]
    # ripiazza questi numeri al posto degli originali
    minuendo <- paste0(substr(minuendo, 0, nchar(minuendo)-1), minuendo_units)
    sottraendo <- paste0(substr(sottraendo, 0, nchar(sottraendo)-1), sottraendo_units)
    }


  final_operations <- paste(minuendo,"-",sottraendo, "=        ")

# write the operations
if(file_output =="~/tmp"){
  dir.create("~/tmp")
}

cat(final_operations, file = paste0(file_output, "/", n_operazioni, "sottrazioni_", Sys.Date(), ".txt"),
    append = TRUE,
    sep = "\n")

cat(paste("operazioni salvate nel file: ", paste0(file_output, "/", n_operazioni, "sottrazioni_", Sys.Date(), ".txt")))

# create a function to open plot directory
open.plot.directory <- function(plot_path){

  if (.Platform$OS.type == "windows"){
    if(!(str_sub(plot_path, start = nchar(plot_path), end = nchar(plot_path)) == "/")){ # if the directory name given ends with "/", then we can play with it without manipulation, otherwise, we need to do some managing
      s <- strsplit(plot_path, "/")[[1]]
      s_sub <- s[1:length(s)-1]
      plot_path_windows <- paste(s_sub, collapse = "\\") %>% paste("\\", sep = "")
    } else{ # if it ends with "/", just translate the "/" character
      plot_path_windows <- gsub(pattern = "/", replacement = "\\\\", x = plot_path)
    }

    shell.exec(plot_path_windows)
  } else{ # if it is not windows
    if(!(str_sub(plot_path, start = nchar(plot_path), end = nchar(plot_path)) == "/")){
      s <- strsplit(plot_path, "/")[[1]]
      s_sub <- s[1:length(s)-1]
      plot_path_unix <- paste(s_sub, collapse = "/") %>% paste("/", sep = "")
      system(paste(Sys.getenv("R_BROWSER"), plot_path_unix))
    } else{
      system(paste(Sys.getenv("R_BROWSER"), plot_path))
    }

  }
}

# open directory of file created
open.plot.directory(paste0(file_output, "/", n_operazioni, "sums_", Sys.Date(), ".txt"))
}

####################################################
# extract values from query raw files

extract_LabData_values_from_raw_traits <- function(path){
  setwd(path)

  excel_traits_file <- list.files(path = ".",
                                  pattern = "*.xlsx")

  traits <- readxl::read_xlsx(path = excel_traits_file, sheet = "Traits")
  mapping <- readxl::read_xlsx(path = excel_traits_file, sheet = "Query",skip = 4)

  library(tidyverse)
  variab_raw_names <- filter(mapping, subquest_en == "value") %>%
    .$qid

  variab_names_explained <-  filter(mapping, subquest_en == "value") %>%
    select(qid,quest_en) %>%
    set_names(c("raw_name", "explained_name"))

  subsetted_data <- select(traits, all_of(variab_raw_names))

  # write csv file
  write.csv(subsetted_data, "only_values_rawColNames.csv")
  write.csv(variables_names_explained, "rawColNames_explained.csv")
}

####################################################

